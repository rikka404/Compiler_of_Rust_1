# 编译原理大作业

# 1 词法分析

以trie树为基础构建了边带有操作的自动机。可以读取一个字符后根据这条边决定是否要回退，是否要把这个加入现字符串，是否需要将现字符串作为一个词。用bit来表示每个操作的有无，所以目前还是可以轻松支持32种操作的，应该大概是用不完的。

如果想要加入新的关键字，首先需要在`util.h`中lexical_type里面加入对应的类型表示，并在对应位置加入`util.cpp`中terminalType，然后要看这个关键字是字母开头的还是符号开头的，如果是前者应该加入`lexical.h`中key_word，后者应该加入`lexical.h`中key_symbol。应该不会有字母和符号混在一起的关键字。

关于注释，我想单行注释可以在读入阶段就去掉，多行注释就需要修改一下自动机的结构了，例如读入"/\*"的时候进入一个特定节点，等读到"\*/"的时候再回到0。

现在已实现注释，不过是直接通过自动机的方法。

---

# 2 语法分析

## 2.1 语法分析总过程：

```cpp
Rules::initRules(is_read);
Rules::initNonTerminalStr();
if (!is_read)
{
    Rules::initFirstSet();
    // 这个阶段需要把产生式右边为空的/zero符号删掉
    Rules::deleteZero();
    Rules::initDFA();
    Rules::calActionTable();
    Rules::saveActionTable();
}
else
{
    Rules::deleteZero();
    Rules::loadActionTable();
}
```

**从`parse_rule.py`中读取文件**

使用.py只是为了方便注释。此文件所有符号必须空格，结尾加#，空行最好也要加#

**反向编码非终结符**

**初始化每个非终结符的FIRST集合**

此步需要产生式中含有空，即`/zero`，因为这样方便算。

**删掉`/zero`**

因为这样才满足分析时的实际含义。

**构建DFA**

**根据DFA构建LR(1)分析表，保存LR(1)分析表**

**实际分析中同时构建语法树，最后输出树结构**

---

## 2.2 第一版语法问题：四朵乌云

ppt中有个看起来像是写错的问题，`<因子> -> <因子>`应该改成`<因子> -> <元素>`

此外还有一个没有在左边出现的非终结符`数组元素`，意义不明。

而真正严重的问题已经化为笼罩在物理大厦上的乌云，像这样的乌云总共有四个，但总结起来就是两片。

### 2.2.1 可赋值元素系列问题

第一个卡住的问题，在于 `6.2 借用与引用`。我们发现，按照原本给出的文法，根本无法识别`*b=2;`这样的语句！

原本的文法：

```
<因子> -> '*' <因子>  | '&' mut <因子> | '&' <因子>
```

这是因为`<赋值语句> -> <可赋值元素> '='<表达式> ';'`左边的可赋值语句并不可以推出含有引用和解引用运算符的符号串。

我们经过多次摸索改法，找到了一种较为合理的改法。

我们认为这几个名词原本意义不明。因子本义是`项`下一层而`元素`上一层的东西，是乘除同级的表达式类别的东西。如果用它来推引用和解引用，那么会出现`*1`这样匪夷所思的东西。

应该定义**这些符号**(`*` `&` `& mut` 以及后面的 `.` `[ ]`)一定是在**可赋值元素**中。产生式改为：

```
<可赋值元素> -> '*' <可赋值元素>  | '&' mut <可赋值元素> | '&' <可赋值元素>
```

问题就解决了。

---

第二个和第三个卡住的问题在于数组和元组，按照所给文法直接照搬会出现问题。我们发现这依旧是意义不明的问题。

8.2和9.2中推出带`[ ]`和带`.`的都推到了奇怪的地方。

```
<可赋值元素> -> <元素> '[' <表达式> ']'
<可迭代结构> -> <元素>
<可赋值元素>-><因子> '.' <NUM>
```

我们定义`a[0].1`这样的都是复杂类型元素，由可赋值元素推出，语法改为即可

```
<可赋值元素> -> <复杂类型元素>
<复杂类型元素> -> <复杂类型元素> '[' <表达式> ']' | <ID> '[' <表达式> ']'
<可迭代结构> -> <可赋值元素>
<复杂类型元素> -> <复杂类型元素> '.' <NUM> | <ID> '.' <NUM>
```

为了使得可赋值元素中可以加`()`，我们还需要添加一条倒推回去的产生式：

```
<复杂类型元素> -> | "(" <可赋值元素> ")"
```

加入这个产生式后会产生歧义，即`(*(&a.3[0].1))`最外层括号可以是元素推表达式的括号，也可以是可赋值元素自己推出的括号。但是规约成哪个意义不大，可以直接按任意优先级取决冲突（见下）。

这样不能识别`*(a+b+1)`这样的符号串，但是rust貌似没有这种写法，只有c++有。

### 2.2.2 LOOP表达式歧义问题

在同时含有LOOP语句和LOOP表达式时，这个文法是含有歧义的！

```rust
loop{
    let mut a = 10;
    break;
}
loop{
    let mut a = 10;
    break;
};
let mut c = 10;
let mut b = loop{
    let mut a = 20;
    if(c >= 100){
        break a;
    }
    a = a + 1;
};
```

第二个`loop`和`;`，无法判断是一个`loop表达式`加`;`规约成语句，还是一个`loop语句`加`空语句`规约成语句。

解决办法：只有第二个`loop`是有歧义的，会引导DFA走向一个有冲突的项目集合。而当有先前信息（比如第三个知道`loop`前面有=），DFA可以正常判断。而事实上有歧义时，其解释为`loop表达式`还是`loop语句`是没有区别的。由于`loop语句`不用加`;`，我们在这种情况下总是将其规约成`loop语句`即可，这就相当于修改了规约的优先级。

---

## 2.3 第二版语法：舍弃可赋值元素 统一表达式

第二版语法`parse_rule2`旨在解决前面提到的可赋值语句带来的一系列问题

经过深思熟虑，我发现我被这个ppt上模棱两可的语法入脑太久了，以至于没有想出这样一个很容易想到的，有理论支撑的，通用的，限制不大而专注于语法分析的，没有歧义和冲突的语法。

回想我们从哪里开始出错：就是这个byd**可赋值元素**，它被绑在了赋值语句的左边，以至于我去思考它的实际含义是一个字母变量加上一堆奇特符号，应该就只能包含(`*` `&` `& mut` 以及后面的 `.` `[ ]`)。

但按统一的方法来看，这凭空给语法加上了很多预定的限制，会使得语义分析也不好分析。而我们现在只是在做语法分析。

事实上，这些符号(加减乘除引用和数组元组符号)很难说要把他们区分开，绑定到特定的什么元素上。

但它们都可以理解为**表达式**中的符号，那么，我们可以把一切`*(a+b+1)`这样的、**赋值语句**左边的等等统一为**表达式**。

```
<赋值语句> -> <表达式> <赋值运算符> <表达式>
```

* 左右都是表达式！！！！！

回想算符优先级，我们现在要做的，就只是理清3.1 3.2中的表达式相关推导中，各种运算符究竟在哪一层，从而根据文法指定出各算符的优先级即可。

* 优先级 is all you need！！！！！

层级结构

```
1 <表达式> -> <加法表达式>
2 <加法表达式> ->  <项> 
3 <项> -> <因子>
4 <因子> -> <元素> 
5 <元素> -> '(' <表达式> ')'
```

根据优先级，越在下面的，其算符结合越早，就是优先级越高。二目运算符号根据符号左右两边非终结符不同决定了计算的唯一顺序(这里是左到右)，优先级也是是没有问题的，我们先填上：

```
1 <表达式> -> <表达式> <比较运算符> <加法表达式>
2 <加法表达式> -> <加法表达式> <加减运算符> <项>
3 <项> -> <项> <乘除模运算符> <因子>
```

现在是有问题的部分：(`*` `&` `& mut` `.` `[ ]`)优先级如何？

对于单目运算符，如果在同一边，一定是靠的越近，越先结合。就像`a[0].1` `a.1[0]`，那么`.` `[ ]`优先级是相同的。

`*` `&` `& mut`在左边，根据资料查阅，其优先级是比`.` `[ ]`低的，但同时他们又比之前所有的运算优先级高。那么我们可以得出`*` `&` `& mut`在第四层因子层，`.` `[ ]`在第五层元素层。

```
4 <因子> -> '*' <因子> | '&' <因子> | '&' 'mut' <因子> 
5 <元素> -> <元素> '.' | <元素> '[' <表达式> ']' | <ID> | <NUM>
```

现在还有一些东西，我认为`[2,1,3]`或`(1,2,3)`应该理解为一个如同数字的元素。

```
<元素> -> '(' <数组赋值列表> ')' | '[' <元组赋值内部> ']'
```

最重要的一件事：

* ~~可赋值元素~~ 这个，不需要了

---

我们写到语义分析时又扩展了语法规则，使其适配or和and

```
1 <表达式> -> <OR表达式>
2 <OR表达式> ->  <AND表达式> 
3 <AND表达式> -> <加法表达式>
4 <加法表达式> ->  <项> 
5 <项> -> <因子>
6 <因子> -> <元素> 
7 <元素> -> '(' <表达式> ')'
```

```
1 <表达式> -> <表达式> <OR> <OR表达式>
2 <OR表达式> -> <OR表达式> <AND> <AND表达式>
3 <AND表达式> -> <AND表达式> <比较运算符> <加法表达式>
4 <加法表达式> -> <加法表达式> <加减运算符> <项>
5 <项> -> <项> <乘除模运算符> <因子>
6 <因子> -> '*' <因子> | '&' <因子> | '&' 'mut' <因子> 
7 <元素> -> <元素> '.' | <元素> '[' <表达式> ']' | <ID> | <NUM>
```

## 2.4 一个问题

```rust
fn main() {
    let mut a:[i32;1] = [1];
    let mut b:[i32;1] = [1,];
    let mut c:(i32) = (1);
}
```

编译通过！

```rust
fn main() {
    let mut c:(i32) = (1);
    println!("{}", c.0)
}
```

```
error[E0610]: `i32` is a primitive type and therefore doesn't have fields
 --> src/main.rs:3:22
  |
3 |     println!("{}", c.0)
  |   
```

不兑！！你是谁？你不是元组，你是int。

```rust
fn main() {
    let mut c:(i32,) = (1,);
    println!("{}", c.0)
}
```

这才是元组。

> 9.1 元组比8.1 数组多了几条产生式，思考原因？

现在知道为什么了吧？元组只有一个的情况下，最后一个必须是逗号。

# 3 语义分析

语义规则：在之前的基础上，每个产生式后面加一条编号，标识规约这一条产生式时调用此编号的函数

属性：怎么存储？map固然强大，但还是不够强大。我们再加上any神器，它就变成了python的字典！！！

## 3.1 作用域语义规则

基本思想：主要用到语句块、语句串、语句以及类似的函数表达式块、函数表达式串。

此外，变量和临时变量需要编译时固定其相对ebp的值，即完全使用偏移量表示一个变量。这需要c_esp同时进行模拟维护。

### 3.1.1 记录变量栈

变量声明语句或变量声明赋值语句规约成语句时，将变量相关信息记录到变量栈中，同时完成语句自身属性（称为声明变量数量）设为1。

### 3.1.2 数量变动

如果是其他东西规约成语句设为0。

当语句、语句串规约成语句串时，父亲声明变量数量为儿子们的加起来。

当规约成语句块时，把语句串中相应数量变量从记录变量栈中弹出。

这样任何时候，记录变量栈中从上到下就是当前作用域从近到远的变量，检查同域下重名问题可以在弹出时检查。

### 3.1.3 查询变量

当遇到一个id的时候，需要查询其相应信息。如果直接查找记录变量栈，复杂度就是o(n)的。我们可以新设一个map，用于映射从变量名到其在记录变量栈中的标号。

由于变量可能会重名，我们需要把名字映射到一个栈，这样栈顶部一定是当前作用域最近的。我们一起维护这两个东西即可。

### 3.1.4 例子

```rust
fn main()
{
    let a: i32 = 4;
    let mut b: i32 = 5;
    {
        let a: bool = true;
        let a: i32 = 6;
        {
            let mut b: i32 = 7;
            b = a;
            out b; // 6
        }
        out b; // 5
    }
    b += a;
    out b; // 9
}
```

运行到输出6时
```
符号表/栈
4   | b    6  |
3   | a    6  |
2   | a  true |
1   | b    5  |
0   | a    4  |
    |---------|
普通变量字典
b : 1, 4
a : 0, 2, 3
```

运行到输出5时
```
符号表/栈
3   | a    6  |
2   | a  true |
1   | b    5  |
0   | a    4  |
    |---------|
普通变量字典
b : 1
a : 0, 2, 3
```

运行到输出9时
```
符号表/栈
1   | b    5  |
0   | a    9  |
    |---------|
普通变量字典
b : 1
a : 0
```

## 3.2 四元式

事已至此，写一下目前我想的四元式的定义吧

首先，放弃四个参数都是字符串的形式，因为我们既然有偏移量了，没有必要再用变量名了

然后就会有个问题：`(+, 100, 200, 300)`，这个300表示内存偏移是没有歧义的，但是前面的100,200，不知道是立即数还是内存偏移量，所以需要一个枚举来区分，所以需要引入操作数寻址类型。

**寻址类型**

* `100` 立即数或四元式标号
* `[100]` 一级相对ebp寻址
* `*[100]` 相对绝对寻址(之所以不使用绝对寻址是因为暂时没有用处，可能只有全局变量会用到)

只使用这些寻址方式，就可以实现引用、数组、元组等功能。

这样我们就实现了后三个参数都使用`int`来做了

**目前的四元式**

注意c_esp是虚指，解释运行时使用；实际esp是实指。
| 范式                  | 说明                                                             |
| --------------------- | ---------------------------------------------------------------- |
| `(:=, x, siz, a)`     | a:=x,直接复制大小为siz的区域                                     |
| `(+=, x, 0, a)`       | 符号有`+= -= *= /= %=`,只能对i32使用                             |
| `(+, a, b, c)`        | 符号有`+ - * / %`,只能对i32使用                                  |
| `(==, a, b, c)`       | 可以对i32和bool使用                                              |
| `(>=, a, b, c)`       | 符号有`> < >= <=`,只能对i32使用                                  |
| `(j, 0, 0, to)`       | 无条件转移,`eip=to`                                              |
| `(jt, a, 0, to)`      | 条件转移                                                         |
| `(j<, a, b, to)`      | 符号有`j> j< j>= j<=`,ab必须是int                                |
| `(push, a, siz, 0)`   | `(:=, a, siz, *c_esp)`,然后`c_esp+=siz`                          |
| `(pop, 0, siz, 0)`    | `esp-=siz`                                                       |
| `(call, 0, 0, to)`    | `(push, eip+1, 4, 0)`,`eip=to`                                   |
| `(build, 0, 0, 0)`    | `(push, ebp, 4, 0)`, 然后`ebp=c_esp-4`                         |
| `(return, a, siz, r)` | 把a地址开始，siz大小的内容放到返回值的地方`r`,和`:=`相同         |
| `(leave, 0, 0, 0)`    | 退出call,即`c_esp=ebp-4,ebp=[0],eip=*c_esp`,等同汇编的leave+ret    |
| `(end, 0, 0, 0)`      | 标识程序结束                                                     |
| `(sea, x, 0, a)`      | 计算绝对地址，即x+ebp，存储到a开始的四字节中                     |
| `(null, 0, 0, 0)`     | 空语句                                                           |
| `(input, a, 0, 0)`    | 输入4字节到a                                                    |
| `(out, a, 0, 0)`      | 输出a的4字节                                                    |

## 3.3 类型判断与计算

### 3.3.1 类型存储

类型有读写类型（变量、常量、临时变量、字面量）和数值类型（很复杂，是树）。

“类型”非终结符和表达式相关的玩意都有数值类型，而表达式相关的玩意还有读写类型。

这个树就十分麻烦。由于表达式中会直接取之前的作为儿子，不好采用直接复制的操作。所以只能用指针的形式，这样管理就跟麻烦了，但是shared_ptr的大手解决了一切。

`& mut [(& i32,[i32;4],i32);4]`树长这样：

```
\--& mut
   \--[;4]
      \--(,,)
         |--& 
         |  \--i32
         |--[;4]
         |  \--i32
         \--i32
```

一些简单的表达式类型运算：

`+ - * /` 类型不变，依旧是int，新产生的读写类型为临时变量。

比较运算符后，由int产生bool，新产生的读写类型为临时变量。

### 3.3.2 引用和解引用

基本思想是使用地址，即指针

**`&`**

1. 检查a的可读类型为变量、临时变量、常量，方可引用
2. 新建一个临时变量t，以相对地址寻址，其数据类型为 `&`类型为根、a的数据类型为儿子
3. t存储a的绝对地址，有两种情况：

* a以相对地址寻址，编译时即可确定其相对ebp地址(如20)，即生成如下四元式：`(sea, 20, 0, t)`。
* a以相对绝对地址寻址，编译时只知道相对ebp地址(如20)处为引用类型，存储着a的绝对地址，即生成如下四元式：`(:=, [20], 4, t)`。

**`&mut`**

1. 检查a的可读类型为变量、临时变量，方可mut引用
2. 新建一个临时变量t，以相对地址寻址，其数据类型为 `&`类型为根、a的数据类型为儿子。
3. t存储a的绝对地址，有两种情况：

* a以相对地址寻址，编译时即可确定其相对ebp地址(如20)，即生成如下四元式：`(sea, 20, 0, t)`
* a以相对绝对地址寻址，编译时只知道相对ebp地址(如20)处为引用类型，存储着a的绝对地址，即生成如下四元式：`(:=, [20], 4, t)`。

`*`

1. 数据类型根为引用或mut引用，方可解引用
2. 若数据类型根为引用，则结果读写类型为变量；若为mut引用，则结果读写类型为常量
3. 结果数据类型为被解引用的数据类型的儿子
4. 结果变量如何寻址，有两种情况：

* 被解引用的引用量以相对地址寻址，编译时即可确定其相对ebp地址(如20)，我们啥也不用做，只需要指定结果变量的寻址方式为相对绝对地址，值为20
* 被解引用的引用量以相对绝对地址寻址，编译时只知道相对ebp地址(如20)处存储引用量的绝对地址。我们需要新建一个引用变量t，类型为临时变量、相对寻址，存储结果变量的绝对地址，即生成如下四元式：`(:=, *[20], 4, t)`，然后结果变量采用相对绝对寻址，值为新建引用变量t的偏移量。

### 3.3.3 数组和元组

**数组元素列表和元组元素列表**

当数组元素列表规约成元素时：

1. 检查所有记录的元素类型是否相同
2. 申请相应大小空间临时变量，把这些元素一个个复制到对应位置
3. 构建相应数组类型，记录偏移量等等

元组列表类似

**数组下标和元组下标**

元组下标较为简单，因为元组类型在编译时完全确定，也不会有使用变量取下标的，都是使用int，其取下标后的类型和绝对地址可以直接确定。

数组取下标需要计算其元素偏移值，具体如下：

1. 如果原元素采用相对寻址，只需要先计算数组元素相对数组名偏移量（下标值乘元素大小），再加上数组偏移量，在加上ebp（取sea）即可
2. 如果原元素采用相对绝对寻址，只需要先计算数组元素相对数组名偏移量（下标值乘元素大小），再加上绝对地址即可

## 3.4 杂项

### 3.4.1 函数栈帧

无论是数组还是什么复杂类型，均采用复制实参传值，也不考虑rust的所有权。

函数调用相当于声明一个临时变量用来存返回值，然后push实参，返回到主函数后pop实参。

因为形参的放入和释放是在外部做的事，而形参在作用域内，需要注意形参在编译和汇编时的区别，即形参需要在编译函数时进入和退出变量栈，但不需要再汇编中放入和释放（因为这是外部调用时做的事）。

```rust
fn sum(a:i32, b:i32, c:i32) -> i32 {
    return a+b+c;
}
fn main() -> i32 {
    let a:i32;
    a = sum(2,3,4);
}
```

```
call之前
|      |
|      |
|      | <-c_esp(模拟虚指)
|  2   | 参数1 <-esp(实际)
|  3   | 参数2
|  4   | 参数3
|  T1  | 临时变量,返回值
|  a   |
|      | <-ebp
|      |
--------
call之后+build栈帧
|      | <-c_esp(模拟虚值指)
| ebp' | <-ebp <-esp(实际)
|  eip |
|  2   | 参数1
|  3   | 参数2
|  4   | 参数3
|  T1  | 临时变量,返回值
|  a   |
|      | <-ebp'
|      |
--------
```

### 3.4.2 临时变量

目前，临时变量和普通变量作用域相同，需要在语句块外弹出（包括汇编和四元式）。

临时变量可以作部分优化：

1.进行加减乘除模时，如果运算中有临时变量，运算结果可以直接使用这个临时变量；如果两个都是临时变量，可以结果使用一个，释放一个，注意释放的那个是在栈顶的那个。

2.进行变量声明赋值语句时，如果右侧是临时变量，声明的变量可以直接采用这个临时变量所在的位置，即该临时变量升级为声明的普通变量。

我们可以通过引用看出实际rust的临时变量如何释放：

```rust
fn main() {
    let mut a:i32 = 5;
    let mut c:&&i32 = &&a;
    println!("{}", **c)
}
```

**正常输出5！！！**

```rust
fn main() {
    let mut a:i32 = 5;
    let mut c:&&i32;
    c = &&a;
    println!("{}", **c)
}
```

```
error[E0716]: temporary value dropped while borrowed
 --> src/main.rs:4:10
  |
4 |     c = &&a;
  |          ^^- temporary value is freed at the end of this statement
  |          |
  |          creates a temporary value which is freed while still in use
5 |     println!("{}", **c)
  |                    --- borrow later used here
```

我们会发现，除了特殊语句，比如声明赋值语句的临时变量（这里是取了一次引用的临时变量）会保留，其他的会在语句结束后就释放，导致了这样的错误。

此外，变量在进行跳转时需要着重考虑释放，具体见控制语句相关翻译。

### 3.4.3 类型推断

最开始思考类型推断时，想要一次扫描完成，即在变量声明时先记下名字，等待到变量被赋值时才确定变量类型，给变量分配对应空间。
但是这种方法会和作用域弹出对应数量变量的规则冲突，这本质上是因为，我们会在一个新的作用域内分配外部作用域下的变量的空间，这会导致顺序乱掉，无法弹出。
所以目前不能支持类型推断。如果需要支持类型推断，至少要预扫描一次，先把没有类型的变量类型推断出来，然后才可以在正确的位置分配变量空间。

## 3.5 有关跳转的指令

## 3.5.1 如何分配内存

首先我们要明确一个事情：类中的c_esp和代码执行过程中的esp变化是不一样的！写这个c_esp的本意是为了模拟计算机的esp从而给变量分配在内存中的位置，但是写到跳转指令的时候就会发现，有的时候c_esp和esp的变化是不同步的。

举个栗子：

计算1 or a + 1 > b - 2

考虑我们编译的时候会干什么：

```
jz 1 T

给a+1 b-2分配内存c_esp += 8

给右表达式分配内存c_esp += 1

jz tempval T

j F

...
```

我们发现，编译完这里的时候，c_esp已经增加了9了，而实际上我们没有进行后一个表达式的运算，所以实际上的esp根本没有加。是不是发现问题的关键了：在走不同分支的时候，esp变化是不同的！这样我们就没法根据c_esp给接下来的变量分配内存了！

再比如

`while a + b > 1 {xxx}`

我们每次运行完xxx之后，都要push 4 push 1来计算表达式，这样esp会一直增加，但是c_esp是走过一遍就不管了的，这也会导致c_esp和esp不同。

以上情况根本的原因就是因为我们没有及时释放掉临时变量导致的，如果每一次执行或者每一条分支执行完对外都是没有临时变量生成的，所以一旦有跳转，需要保证执行完及时释放临时变量。

## 3.5.2 中间如何插入控制语句

考虑我们规约A -> B C的时候，自下而上会分别产生B.code C.code A.code，但是如果有跳转的话，实际上B C之间是要插入控制语句的，我们以IF语句为例

` IF语句 -> if 表达式 语句块 else部分`

实际应该是:

```
表达式.code
jz else部分
语句块.code
j L
else部分.code
L
```

发现没有，它并不符合B.code C.code A.code的形式，我们规约完儿子之后，要在之间插入代码！

但是这样的形式也改不了，是由自下而上规约的过程决定的，所以我们可以参考课本上在中间插入M的方法，M->/zero，规约到M的时候插入控制语句。

` IF语句 -> if 表达式 M 语句块 M else部分`

当然，我们无法在规约到M的时候知道M具体跳转的位置，但是至少我们把四元式先填上去了，这样我们就可以记录这个四元式的下标作为M的字段，向上传递到IF语句的时候在填上就行。

## 3.5.3 or and语句的翻译

按照标准，A or B不能直接把AB都算出来再取or，必须先算A，如果A为真则不算B。

这就导致了分支的产生，就要考虑及时释放掉中间的临时变量，也就是A B产生的临时变量。

```
// 表达式 -> 表达式 or M OR表达式
    /**
     * code a
     * code M :
     *      jnz A - AT
     * code b
     * 这以上的都是规约之前就做好的
     * jnz B BT
     * pop B + A
     * push c
     * c := 0
     * j next
     * AT: pop A
     * j T
     * BT: pop B + A
     * T: push c
     * c := 1
     * next:
     */
```

A真，释放A并到T；B真，释放B+A并到T；B假，释放B+A并到F。这样对外来说，只有此表达式本身的1字节。

同理，A and B的翻译

```
    // OR表达式 -> OR表达式 and M AND表达式
    /**
     * code a
     * code M :
     *      jz A - AF
     * code b
     * 这以上的都是规约之前就做好的
     * jz B BF
     * pop B + A
     * push c
     * c := 1
     * j next
     * AF: pop A
     * j F
     * BF: pop B + A
     * F: push c
     * c := 0
     * next:
     */
```

对外也只有一个字节，c_esp += 1

## 3.5.4 IF语句的翻译

应该是最好做的一个，因为并不涉及内存分配，控制c_esp相关，因为代码块在规约出来的时候就已经把内部的变量释放掉了。

```
// IF语句 -> if 表达式 M 语句块 M else部分
    /**
     * 表达式code
     * M1code jz 表达式 M2 + 1
     * M1 + 1 : 语句块code
     * M2code j L
     * M2 + 1 : else部分code
     * L 
     */
```

## 3.5.5 三种循环语句的翻译

LOOP语句不考虑其可以规约成表达式的操作的话，是很好翻译的，只需要在最后跳转回开始的M的位置即可。

WHILE语句需要处理内存相关，无论是表达式为真的路径还是表达式为假的路径，都需要及时释放掉表达式的内存空间。

```
    // WHILE语句 -> while M 表达式 M 语句块
    /**
     * M1 : null
     * 表达式code
     * M2code : jz A L
     * 语句块code
     * C: pop A
     * j M1
     * L: pop A
     * 
     */
```

**这样还有一些问题**

原本的for循环结构无法按上述处理

```
# 5.2 for循环结构
XUN_HUAN_YU_JU -> FOR_YU_JU #
FOR_YU_JU -> /for BIAN_LIANG_SHENG_MING_NEI_BU /in KE_DIE_DAI_JIE_GOU YU_JU_KUAI #
KE_DIE_DAI_JIE_GOU -> BIAO_DA_SHI /ddot BIAO_DA_SHI #
#
```

因为这里只有规约到for语句时，才能综合出for语句开始定义变量的类型，才可能放进变量栈里，但这时语句块已经规约了，它又得删除了。

我们需要小修改一下，让它能在语句块没规约前，先把变量记录好。

```
# 5.2 for循环结构
XUN_HUAN_YU_JU -> FOR_YU_JU #
FOR_YU_JU -> FOR_YU_JU_SHENG_MING YU_JU_KUAI #
FOR_YU_JU_SHENG_MING -> /for BIAN_LIANG_SHENG_MING_NEI_BU /in KE_DIE_DAI_JIE_GOU #
KE_DIE_DAI_JIE_GOU -> BIAO_DA_SHI /ddot BIAO_DA_SHI #
```

这是FOR语句相关的逻辑

```
    // FOR语句 -> FOR语句声明 M_FOR 语句块
    /**
     * FOR语句声明code:声明e并赋初值end,声明i并赋初值beg-1
     * M_FOR : null
     * M:M_FOR : i++
     * M_FOR : j>= i end - L
     * 语句块code
     * j M
     * L pop所有变量
     * 语句块内的变量已经释放掉了，无需再次释放
     *
     * 考虑数组:
     * FOR语句声明code:声明一个存储 当前数组元素绝对地址-siz 的a和结束处的a_end、一个存储数组元素的变量x
     * M:M_FOR : a+=siz
     * M_FOR : j> a a_end - L
     * M_FOR : x:=*a
     * 语句块code
     * j M
     * L pop所有变量
     */
```

## 3.5.6 break语句和continue语句的翻译

首先，二者都是一个跳转语句，但是翻译到这里的时候，还没有规约成上面的循环语句，所以是不能及时确定跳转的位置的，需要标记代填，用list的方式把一个循环语句内所有的break和continue对应的跳转语句串成链表，在规约成循环语句的时候统一回填。

其次，当出现break或continue的时候，还需要将当前语句块内的变量释放，不然会导致对外有多余的变量导致后面的c_esp无法与esp统一。但同样，规约到这里的时候无法得知需要释放多少变量，但是我们可以记录当前的c_esp，并记录循环语句开始时候的M位置时候的c_esp，同样把这样的pop语句串成链表，在规约到循环语句的时候用记录的c_esp减去M时刻的c_esp得到需要释放的变量大小。


## 3.6 函数表达式语句块相关

### 函数表达式语句块

由于函数表达式不是个完整的函数，无法提前得知函数表达式的返回值的类型，所以使用原来实现函数的方法来实现函数表达式语句块就十分困难。

基本的实现思路是：尝试把返回值放在函数语句块占用内存的开头的位置，然后再返回的时候pop要少一个这个类型的大小，这样能够实现对外面来说栈顶就是返回值。

```
返回之前
|      |
|      |
|      | <-esp
|  y   | 
|  x   | 
|  x   | 
|  x   | 
|  x   |
|  x   | <-语句块开始的时候的esp
|      |
--------
返回之后
|      |
|      |
|      | 
|      | 
|      | 
|      | 
|      | 
|      | <- esp
|  y   | 
|      |
--------
```

但这就要求我们再规约出函数表达式语句块的时候，就要知道返回类型和返回的内容，以及语句块开始的esp，前者可以从表达式规约上来的时候记录，而后者就没什么办法，只能在规约的时候加入空串M：` 函数表达式语句块 -> M { 函数表达式语句串 }` ，让M中包含字段esp，规约出M的时候记录的esp就是起始时候的esp。

首先把返回值copy到其实esp的地方，然后pop。在pop的时候，仍然是pop相同数量的变量，但是在pop之前先让c_esp和esp增加一个返回类型的大小，这样在pop结束的时候c_esp和esp就是我们期望的值，唯一没有满足的就是我们的变量表里面没有存这个返回值的临时变量，但这时候它就在`c_esp - 返回类型大小`的位置，我们直接手动设置它的地址并添加就可以了。

### IF表达式

首先我认为两个函数表达式语句块类型必须相同。这样的话，就和普通IF语句的思路差不多了。最后规约成IF表达式的时候，无论走的是那一条路，最后出来的时候，esp和c_esp都是一样的，并且返回值都是栈顶的那个元素且类型相同，此时直接返回栈顶的元素即可。

### LOOP表达式语句

在本文法中，由于一些前置原因，LOOP表达式和LOOP语句统一成了LOOP语句，所以必须要在规约成LOOP语句的时候根据字段来区分是否有返回值。

核心的难点就在于break xxx这样的东西。这里不仅要pop掉所有当前的变量，还要像函数表达式语句块一样将返回值copy到语句块起始的地方，且这个地方无法立刻得知，而这里无论如何改变c_esp都会导致c_esp与esp不同步。

首先解决copy位置位置的问题：和之前的思路一样，先不填，而把这样的语句串成一个链表，规约成函数表达式语句块的时候统一填上。

然后考虑c_esp的变化：最好的方式就是不管！因为如果出现了break，那么这个语句块从break之后的语句实际上完全不会执行，所以这些语句的正确性是可以不考虑的，而当这个语句块结束的时候，也会自动pop掉这个语句块内的所有变量，于是对外c_esp也是对的。所以从四元式的层面，我们只需要像函数表达式一样push一个返回值类型大小，然后像break一样pop掉所有变量，再跳转，出去的时候就是栈顶放一个返回值的状态！而对于编译层面的c_esp，由于没有刻意修改，再整个过程中都是正常且能够与esp保持同步的，唯一不同步的地方就在于break出去之后，c_esp是没有保留返回值的空间的，而esp是在这个返回值之上，所以此时直接新建临时变量作为返回值，地址就是c_esp，然后c_esp加上返回类型大小，与esp重新同步。

```
返回之前
|      |
|      |
|      | 
|      | 
|      | 
|      | 
|      | <- esp 
|返回值y| 
|返回值y| <-c_esp
|      | 
|      |
------
````


## 小tip

如果觉得未实现的函数报的warning太多，可以在编译语句里加上这一个参数`-Wno-unused-parameter`来屏蔽掉所有“没有使用某参数”的warning


# 4 目标代码生成

主要文件在`obj`下。

我们语义分析中已经实现了四元式的模拟执行，该程序已经成为了一个解释器，能直接得到结果。目前，我们尝试将中间代码翻译成x86的汇编.s形式，即AT&T格式，然后再通过32位minGW编译成exe。对于input和output，我们需要和一个含有input函数和output函数的.c文件，在翻译的.s文件中对其进行调用。我们原来的调用语句和实际操作系统有一些小区别，因此我们首先对函数调用做了一些小修改。要注意的是，我们四元式地址的排布和现实地址的排布刚好是反的，差一个负号。

翻译得到.s后，使用32位gcc编译成exe：
```
gcc -m32 main.s io.s -o xx.exe
```

需要在`obj/`下放置文件夹`mingw32`，里面是32位gcc编译器

## 4.1 重要说明

我们写到这才发现我们的栈增长方向刚好和现实中栈的增长方向是反的，但仅仅是方向反了，其他都是对的：

我们四元式：-4是牢eip，0是牢ebp，4、8是局部变量，-8，-12是参数地址
现实计算机：4是牢eip，0是牢ebp，-4、-8是局部变量，8，12是参数地址

为了最小化改动，我们并不打算重改一遍语义分析。我们考虑把栈反过来的方法。

1.在翻译汇编时把偏移量取负

2.在翻译sea时，变成ebp减去那个数

3.其次还有在部分四元式的生成中直接写入了和栈方向相关逻辑。这里必须在语义分析中小改。

有：

数组和元组中计算元素绝对地址的相关四元式生成，数组/元组名为绝对寻址时，需要产生+的四元式，由于栈方向改变需要变成-。

for in 数组：原循环逻辑也使用了栈方向，需要反过来。代码里我没有改注释，真实逻辑就在这里写了。

```
FOR语句声明code:声明一个存储 当前数组元素绝对地址+siz 的a 
                和 结束处的a_end = a-数组大小、一个存储数组元素的变量x
M:M_FOR : a-=siz
M_FOR : j< a a_end - L
M_FOR : x:=*a
语句块code
j M
L pop所有变量

```

这些改动会也影响之前的解释器，我们把解释器也用类似实际操作系统的栈反了一遍。