# 编译原理大作业1——词法和语法分析

## 1 词法分析

以trie树为基础构建了边带有操作的自动机。可以读取一个字符后根据这条边决定是否要回退，是否要把这个加入现字符串，是否需要将现字符串作为一个词。用bit来表示每个操作的有无，所以目前还是可以轻松支持32种操作的，应该大概是用不完的。

如果想要加入新的关键字，首先需要在`util.h`中lexical_type里面加入对应的类型表示，并在对应位置加入`util.cpp`中terminalType，然后要看这个关键字是字母开头的还是符号开头的，如果是前者应该加入`lexical.h`中key_word，后者应该加入`lexical.h`中key_symbol。应该不会有字母和符号混在一起的关键字。

关于注释，我想单行注释可以在读入阶段就去掉，多行注释就需要修改一下自动机的结构了，例如读入"/\*"的时候进入一个特定节点，等读到"\*/"的时候再回到0。

现在已实现注释，不过是直接通过自动机的方法。

---

## 2 词法分析

## 2.1 词法分析总过程：
```cpp
Rules::initRules(is_read);
Rules::initNonTerminalStr();
if (!is_read)
{
    Rules::initFirstSet();
    // 这个阶段需要把产生式右边为空的/zero符号删掉
    Rules::deleteZero();
    Rules::initDFA();
    Rules::calActionTable();
    Rules::saveActionTable();
}
else
{
    Rules::deleteZero();
    Rules::loadActionTable();
}
```
**从`parse_rule.py`中读取文件**

使用.py只是为了方便注释。此文件所有符号必须空格，结尾加#，空行最好也要加#

**反向编码非终结符**

**初始化每个非终结符的FIRST集合**

此步需要产生式中含有空，即`/zero`，因为这样方便算。

**删掉`/zero`**

因为这样才满足分析时的实际含义。

**构建DFA**

**根据DFA构建LR(1)分析表，保存LR(1)分析表**

**实际分析中同时构建语法树，最后输出树结构**

---

## 2.2 第一版语法问题：四朵乌云

ppt中有个看起来像是写错的问题，`<因子> -> <因子>`应该改成`<因子> -> <元素>`

此外还有一个没有在左边出现的非终结符`数组元素`，意义不明。

而真正严重的问题已经化为笼罩在物理大厦上的乌云，像这样的乌云总共有四个，但总结起来就是两片。

## 2.2.1 可赋值元素系列问题

第一个卡住的问题，在于 `6.2 借用与引用`。我们发现，按照原本给出的文法，根本无法识别`*b=2;`这样的语句！

原本的文法：
```
<因子> -> '*' <因子>  | '&' mut <因子> | '&' <因子>
```

这是因为`<赋值语句> -> <可赋值元素> '='<表达式> ';'`左边的可赋值语句并不可以推出含有引用和解引用运算符的符号串。

我们经过多次摸索改法，找到了一种较为合理的改法。

我们认为这几个名词原本意义不明。因子本义是`项`下一层而`元素`上一层的东西，是乘除同级的表达式类别的东西。如果用它来推引用和解引用，那么会出现`*1`这样匪夷所思的东西。

应该定义**这些符号**(`*` `&` `& mut` 以及后面的 `.` `[ ]`)一定是在**可赋值元素**中。产生式改为：

```
<可赋值元素> -> '*' <可赋值元素>  | '&' mut <可赋值元素> | '&' <可赋值元素>
```

问题就解决了。

---
第二个和第三个卡住的问题在于数组和元组，按照所给文法直接照搬会出现问题。我们发现这依旧是意义不明的问题。

8.2和9.2中推出带`[ ]`和带`.`的都推到了奇怪的地方。
```
<可赋值元素> -> <元素> '[' <表达式> ']'
<可迭代结构> -> <元素>
<可赋值元素>-><因子> '.' <NUM>
```
我们定义`a[0].1`这样的都是复杂类型元素，由可赋值元素推出，语法改为即可
```
<可赋值元素> -> <复杂类型元素>
<复杂类型元素> -> <复杂类型元素> '[' <表达式> ']' | <ID> '[' <表达式> ']'
<可迭代结构> -> <可赋值元素>
<复杂类型元素> -> <复杂类型元素> '.' <NUM> | <ID> '.' <NUM>
```

为了使得可赋值元素中可以加`()`，我们还需要添加一条倒推回去的产生式：
```
<复杂类型元素> -> | "(" <可赋值元素> ")"
```
加入这个产生式后会产生歧义，即`(*(&a.3[0].1))`最外层括号可以是元素推表达式的括号，也可以是可赋值元素自己推出的括号。但是规约成哪个意义不大，可以直接按任意优先级取决冲突（见下）。

这样不能识别`*(a+b+1)`这样的符号串，但是rust貌似没有这种写法，只有c++有。


## 2.2.2 LOOP表达式歧义问题

在同时含有LOOP语句和LOOP表达式时，这个文法是含有歧义的！

```rust
loop{
    let mut a = 10;
    break;
}
loop{
    let mut a = 10;
    break;
};
let mut c = 10;
let mut b = loop{
    let mut a = 20;
    if(c >= 100){
        break a;
    }
    a = a + 1;
};
```
第二个`loop`和`;`，无法判断是一个`loop表达式`加`;`规约成语句，还是一个`loop语句`加`空语句`规约成语句。

解决办法：只有第二个`loop`是有歧义的，会引导DFA走向一个有冲突的项目集合。而当有先前信息（比如第三个知道`loop`前面有=），DFA可以正常判断。而事实上有歧义时，其解释为`loop表达式`还是`loop语句`是没有区别的。由于`loop语句`不用加`;`，我们在这种情况下总是将其规约成`loop语句`即可，这就相当于修改了规约的优先级。

---

## 2.3 第二版语法：舍弃可赋值元素 统一表达式

第二版语法`parse_rule2`旨在解决前面提到的可赋值语句带来的一系列问题

经过深思熟虑，我发现我被这个ppt上模棱两可的语法入脑太久了，以至于没有想出这样一个很容易想到的，有理论支撑的，通用的，限制不大而专注于语法分析的，没有歧义和冲突的语法。

回想我们从哪里开始出错：就是这个byd**可赋值元素**，它被绑在了赋值语句的左边，以至于我去思考它的实际含义是一个字母变量加上一堆奇特符号，应该就只能包含(`*` `&` `& mut` 以及后面的 `.` `[ ]`)。

但按统一的方法来看，这凭空给语法加上了很多预定的限制，会使得语义分析也不好分析。而我们现在只是在做语法分析。

事实上，这些符号(加减乘除引用和数组元组符号)很难说要把他们区分开，绑定到特定的什么元素上。

但它们都可以理解为**表达式**中的符号，那么，我们可以把一切`*(a+b+1)`这样的、**赋值语句**左边的等等统一为**表达式**。

```
<赋值语句> -> <表达式> <赋值运算符> <表达式>
```

* 左右都是表达式！！！！！

回想算符优先级，我们现在要做的，就只是理清3.1 3.2中的表达式相关推导中，各种运算符究竟在哪一层，从而根据文法指定出各算符的优先级即可。

* 优先级 is all you need！！！！！

层级结构
```
1 <表达式> -> <加法表达式>
2 <加法表达式> ->  <项> 
3 <项> -> <因子>
4 <因子> -> <元素> 
5 <元素> -> '(' <表达式> ')'
```

根据优先级，越在下面的，其算符结合越早，就是优先级越高。二目运算符号根据符号左右两边非终结符不同决定了计算的唯一顺序(这里是左到右)，优先级也是是没有问题的，我们先填上：

```
1 <表达式> -> <表达式> <比较运算符> <加法表达式>
2 <加法表达式> -> <加法表达式> <加减运算符> <项>
3 <项> -> <项> <乘除模运算符> <因子>
```

现在是有问题的部分：(`*` `&` `& mut` `.` `[ ]`)优先级如何？

对于单目运算符，如果在同一边，一定是靠的越近，越先结合。就像`a[0].1` `a.1[0]`，那么`.` `[ ]`优先级是相同的。

`*` `&` `& mut`在左边，根据资料查阅，其优先级是比`.` `[ ]`低的，但同时他们又比之前所有的运算优先级高。那么我们可以得出`*` `&` `& mut`在第四层因子层，`.` `[ ]`在第五层元素层。

```
4 <因子> -> '*' <因子> | '&' <因子> | '&' 'mut' <因子> 
5 <元素> -> <元素> '.' | <元素> '[' <表达式> ']' | <ID> | <NUM>
```

现在还有一些东西，我认为`[2,1,3]`或`(1,2,3)`应该理解为一个如同数字的元素。

```
<元素> -> '(' <数组赋值列表> ')' | '[' <元组赋值内部> ']'
```

最重要的一件事：

* ~~可赋值元素~~ 这个，不需要了

