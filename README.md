# 编译原理大作业

## 1 词法分析

以trie树为基础构建了边带有操作的自动机。可以读取一个字符后根据这条边决定是否要回退，是否要把这个加入现字符串，是否需要将现字符串作为一个词。用bit来表示每个操作的有无，所以目前还是可以轻松支持32种操作的，应该大概是用不完的。

如果想要加入新的关键字，首先需要在`util.h`中lexical_type里面加入对应的类型表示，并在对应位置加入`util.cpp`中terminalType，然后要看这个关键字是字母开头的还是符号开头的，如果是前者应该加入`lexical.h`中key_word，后者应该加入`lexical.h`中key_symbol。应该不会有字母和符号混在一起的关键字。

关于注释，我想单行注释可以在读入阶段就去掉，多行注释就需要修改一下自动机的结构了，例如读入"/\*"的时候进入一个特定节点，等读到"\*/"的时候再回到0。

现在已实现注释，不过是直接通过自动机的方法。

---

## 2 词法分析

## 2.1 词法分析总过程：

```cpp
Rules::initRules(is_read);
Rules::initNonTerminalStr();
if (!is_read)
{
    Rules::initFirstSet();
    // 这个阶段需要把产生式右边为空的/zero符号删掉
    Rules::deleteZero();
    Rules::initDFA();
    Rules::calActionTable();
    Rules::saveActionTable();
}
else
{
    Rules::deleteZero();
    Rules::loadActionTable();
}
```

**从`parse_rule.py`中读取文件**

使用.py只是为了方便注释。此文件所有符号必须空格，结尾加#，空行最好也要加#

**反向编码非终结符**

**初始化每个非终结符的FIRST集合**

此步需要产生式中含有空，即`/zero`，因为这样方便算。

**删掉`/zero`**

因为这样才满足分析时的实际含义。

**构建DFA**

**根据DFA构建LR(1)分析表，保存LR(1)分析表**

**实际分析中同时构建语法树，最后输出树结构**

---

## 2.2 第一版语法问题：四朵乌云

ppt中有个看起来像是写错的问题，`<因子> -> <因子>`应该改成`<因子> -> <元素>`

此外还有一个没有在左边出现的非终结符`数组元素`，意义不明。

而真正严重的问题已经化为笼罩在物理大厦上的乌云，像这样的乌云总共有四个，但总结起来就是两片。

## 2.2.1 可赋值元素系列问题

第一个卡住的问题，在于 `6.2 借用与引用`。我们发现，按照原本给出的文法，根本无法识别`*b=2;`这样的语句！

原本的文法：

```
<因子> -> '*' <因子>  | '&' mut <因子> | '&' <因子>
```

这是因为`<赋值语句> -> <可赋值元素> '='<表达式> ';'`左边的可赋值语句并不可以推出含有引用和解引用运算符的符号串。

我们经过多次摸索改法，找到了一种较为合理的改法。

我们认为这几个名词原本意义不明。因子本义是`项`下一层而`元素`上一层的东西，是乘除同级的表达式类别的东西。如果用它来推引用和解引用，那么会出现`*1`这样匪夷所思的东西。

应该定义**这些符号**(`*` `&` `& mut` 以及后面的 `.` `[ ]`)一定是在**可赋值元素**中。产生式改为：

```
<可赋值元素> -> '*' <可赋值元素>  | '&' mut <可赋值元素> | '&' <可赋值元素>
```

问题就解决了。

---

第二个和第三个卡住的问题在于数组和元组，按照所给文法直接照搬会出现问题。我们发现这依旧是意义不明的问题。

8.2和9.2中推出带`[ ]`和带`.`的都推到了奇怪的地方。

```
<可赋值元素> -> <元素> '[' <表达式> ']'
<可迭代结构> -> <元素>
<可赋值元素>-><因子> '.' <NUM>
```

我们定义`a[0].1`这样的都是复杂类型元素，由可赋值元素推出，语法改为即可

```
<可赋值元素> -> <复杂类型元素>
<复杂类型元素> -> <复杂类型元素> '[' <表达式> ']' | <ID> '[' <表达式> ']'
<可迭代结构> -> <可赋值元素>
<复杂类型元素> -> <复杂类型元素> '.' <NUM> | <ID> '.' <NUM>
```

为了使得可赋值元素中可以加`()`，我们还需要添加一条倒推回去的产生式：

```
<复杂类型元素> -> | "(" <可赋值元素> ")"
```

加入这个产生式后会产生歧义，即`(*(&a.3[0].1))`最外层括号可以是元素推表达式的括号，也可以是可赋值元素自己推出的括号。但是规约成哪个意义不大，可以直接按任意优先级取决冲突（见下）。

这样不能识别`*(a+b+1)`这样的符号串，但是rust貌似没有这种写法，只有c++有。

## 2.2.2 LOOP表达式歧义问题

在同时含有LOOP语句和LOOP表达式时，这个文法是含有歧义的！

```rust
loop{
    let mut a = 10;
    break;
}
loop{
    let mut a = 10;
    break;
};
let mut c = 10;
let mut b = loop{
    let mut a = 20;
    if(c >= 100){
        break a;
    }
    a = a + 1;
};
```

第二个`loop`和`;`，无法判断是一个`loop表达式`加`;`规约成语句，还是一个`loop语句`加`空语句`规约成语句。

解决办法：只有第二个`loop`是有歧义的，会引导DFA走向一个有冲突的项目集合。而当有先前信息（比如第三个知道`loop`前面有=），DFA可以正常判断。而事实上有歧义时，其解释为`loop表达式`还是`loop语句`是没有区别的。由于`loop语句`不用加`;`，我们在这种情况下总是将其规约成`loop语句`即可，这就相当于修改了规约的优先级。

---

## 2.3 第二版语法：舍弃可赋值元素 统一表达式

第二版语法`parse_rule2`旨在解决前面提到的可赋值语句带来的一系列问题

经过深思熟虑，我发现我被这个ppt上模棱两可的语法入脑太久了，以至于没有想出这样一个很容易想到的，有理论支撑的，通用的，限制不大而专注于语法分析的，没有歧义和冲突的语法。

回想我们从哪里开始出错：就是这个byd**可赋值元素**，它被绑在了赋值语句的左边，以至于我去思考它的实际含义是一个字母变量加上一堆奇特符号，应该就只能包含(`*` `&` `& mut` 以及后面的 `.` `[ ]`)。

但按统一的方法来看，这凭空给语法加上了很多预定的限制，会使得语义分析也不好分析。而我们现在只是在做语法分析。

事实上，这些符号(加减乘除引用和数组元组符号)很难说要把他们区分开，绑定到特定的什么元素上。

但它们都可以理解为**表达式**中的符号，那么，我们可以把一切`*(a+b+1)`这样的、**赋值语句**左边的等等统一为**表达式**。

```
<赋值语句> -> <表达式> <赋值运算符> <表达式>
```

* 左右都是表达式！！！！！

回想算符优先级，我们现在要做的，就只是理清3.1 3.2中的表达式相关推导中，各种运算符究竟在哪一层，从而根据文法指定出各算符的优先级即可。

* 优先级 is all you need！！！！！

层级结构

```
1 <表达式> -> <加法表达式>
2 <加法表达式> ->  <项> 
3 <项> -> <因子>
4 <因子> -> <元素> 
5 <元素> -> '(' <表达式> ')'
```

根据优先级，越在下面的，其算符结合越早，就是优先级越高。二目运算符号根据符号左右两边非终结符不同决定了计算的唯一顺序(这里是左到右)，优先级也是是没有问题的，我们先填上：

```
1 <表达式> -> <表达式> <比较运算符> <加法表达式>
2 <加法表达式> -> <加法表达式> <加减运算符> <项>
3 <项> -> <项> <乘除模运算符> <因子>
```

现在是有问题的部分：(`*` `&` `& mut` `.` `[ ]`)优先级如何？

对于单目运算符，如果在同一边，一定是靠的越近，越先结合。就像`a[0].1` `a.1[0]`，那么`.` `[ ]`优先级是相同的。

`*` `&` `& mut`在左边，根据资料查阅，其优先级是比`.` `[ ]`低的，但同时他们又比之前所有的运算优先级高。那么我们可以得出`*` `&` `& mut`在第四层因子层，`.` `[ ]`在第五层元素层。

```
4 <因子> -> '*' <因子> | '&' <因子> | '&' 'mut' <因子> 
5 <元素> -> <元素> '.' | <元素> '[' <表达式> ']' | <ID> | <NUM>
```

现在还有一些东西，我认为`[2,1,3]`或`(1,2,3)`应该理解为一个如同数字的元素。

```
<元素> -> '(' <数组赋值列表> ')' | '[' <元组赋值内部> ']'
```

最重要的一件事：

* ~~可赋值元素~~ 这个，不需要了

---

## 3 语义分析

语义规则：含有set的参数表示设置到的值，含有get的参数表示获取的位置

例子：`YU_JU_KUAI -> /lbra YU_JU_CHUAN /rbra [ 1 statePop 1 ] #`

值：0 int 1 bool 2 mut& 3 & 4 数组 5 元组  0 变量 1 常量 2 字面量

---

**喜报：助教说不用写语义分析了。写这玩意规则的时候感觉我在挑战编译器的下限。**

神人代码举例:

**选择表达式的可读类型怎么检查？**

```rust
fn main() {
    let mut b = 2;
    let mut a:& mut i32;
    a = & mut 
    (if 7 > 1 {
            3
        }
        else {
            b
        }
    );
}
```

这居然能编译通过（当然实际访问的时候还是会出错）。

**别整你那类型推断了**

```rust
fn main() {
    let mut a;
    if 1 > 7 {
        a = [1,2];
    }
    else {
        a = 1;
    }
}
```

```
error[E0308]: mismatched types
 --> src/main.rs:7:13
  |
2 |     let mut a;
  |         ----- expected due to the type of this binding
...
7 |         a = 1;
  |             ^ expected `[{integer}; 2]`, found integer
```

先来先服务说是

**句读之不解**

```rust
fn main() {
    let mut a:[i32;1] = [1];
    let mut b:[i32;1] = [1,];
    let mut c:(i32) = (1);
}
```

编译通过！

```rust
fn main() {
    let mut c:(i32) = (1);
    println!("{}", c.0)
}
```

```
error[E0610]: `i32` is a primitive type and therefore doesn't have fields
 --> src/main.rs:3:22
  |
3 |     println!("{}", c.0)
  |   
```

不兑！！你是谁？你不是元组，你是int。

```rust
fn main() {
    let mut c:(i32,) = (1,);
    println!("{}", c.0)
}
```

这才是元组。

> 9.1 元组比8.1 数组多了几条产生式，思考原因？

现在知道为什么了吧？元组只有一个的情况下，最后一个必须是逗号。

写这些神秘语义规则实在是太烧脑了，已经燃尽了。接下来的思想介绍就将就看看吧。

---

## 3.1 作用域语义规则

基本思想：主要用到语句块、语句串、语句以及类似的函数表达式块、函数表达式串。

## 3.1.1 记录变量栈

变量声明语句或变量声明赋值语句规约成语句时，将变量相关信息记录到变量栈中，即`statePush 1`，同时完成语句自身属性（称为声明变量数量）设为1。

## 3.1.2 数量变动

如果是其他东西规约成语句设为0 `stateSet 0` 。

当语句、语句串规约成语句串时，父亲声明变量数量为儿子们的加起来 `stateSum 0 1` 。

当规约成语句块时，把语句串中相应数量变量从记录变量栈中弹出。

这样任何时候，记录变量栈中从上到下就是当前作用域从近到远的变量，但是好像无法检查同域下重名问题？

```
语句块 -> "(" 语句串 ")" [ 1 statePop 1 ] #
语句串 -> 空 [ 1 stateSet 0 ] #
语句串 -> 语句 语句串 [ 1 stateSum 0 1 ] #
语句 -> ";" [ 1 stateSet 0 ] #
```

## 3.1.3 这样还有一些问题

原本的for循环结构无法按上述处理

```
# 5.2 for循环结构
XUN_HUAN_YU_JU -> FOR_YU_JU #
FOR_YU_JU -> /for BIAN_LIANG_SHENG_MING_NEI_BU /in KE_DIE_DAI_JIE_GOU YU_JU_KUAI #
KE_DIE_DAI_JIE_GOU -> BIAO_DA_SHI /ddot BIAO_DA_SHI #
#
```

因为这里只有规约到for语句时，才能综合出for语句开始定义变量的类型，才可能放进变量栈里，但这时语句块已经规约了，它又得删除了。

我们需要小修改一下，让它能在语句块没规约前，先把变量记录好。

```
# 5.2 for循环结构
XUN_HUAN_YU_JU -> FOR_YU_JU #
FOR_YU_JU -> FOR_YU_JU_SHENG_MING YU_JU_KUAI [ 1 statePop 0 ] #
FOR_YU_JU_SHENG_MING -> /for BIAN_LIANG_SHENG_MING_NEI_BU /in KE_DIE_DAI_JIE_GOU [ 1 iteration 1 ] #
KE_DIE_DAI_JIE_GOU -> BIAO_DA_SHI /ddot BIAO_DA_SHI [ 5 numTypeCheck 0 0 numTypeCheck 2 0 numTypeSet 4 numTypeSon 0 numTypeDel 2 ] #
```

`iteration` 就是从 可迭代结构中把类型解出来给那个定义的变量，然后记录。

---

## 3.2 类型判断

## 3.2.1 类型存储

类型有读写类型（变量、常量、字面量）和数值类型（很复杂，是树）。

“类型”非终结符和表达式相关的玩意都有数值类型，而表达式相关的玩意还有读写类型。

这个树就十分麻烦。由于表达式中会直接取之前的作为儿子，不好采用直接复制的操作。所以只能用指针的形式，这样管理就跟麻烦了，要考虑del和new（set就是new，新建一个节点）。

存到变量栈中时，直接把类型get到栈里。

从变量栈中取类型，采用深拷贝把类型复制到表达式里。这样做是为了del方便。

`& mut [(& i32,[i32;4],i32);4]`树长这样：

```
\--& mut
   \--[;4]
      \--(,,)
         |--& 
         |  \--i32
         |--[;4]
         |  \--i32
         \--i32
```

## 3.2.2 表达式类型运算

很恶心，你自己看吧

## 小tip

如果觉得未实现的函数报的warning太多，可以在编译语句里加上这一个参数`-Wno-unused-parameter`来屏蔽掉所有“没有使用某参数”的warning
