# 编译原理大作业1——词法和语法分析

## 1 词法分析

以trie树为基础构建了边带有操作的自动机。可以读取一个字符后根据这条边决定是否要回退，是否要把这个加入现字符串，是否需要将现字符串作为一个词。用bit来表示每个操作的有无，所以目前还是可以轻松支持32种操作的，应该大概是用不完的。

如果想要加入新的关键字，首先需要在`util.h`中lexical_type里面加入对应的类型表示，并在对应位置加入`util.cpp`中terminalType，然后要看这个关键字是字母开头的还是符号开头的，如果是前者应该加入`lexical.h`中key_word，后者应该加入`lexical.h`中key_symbol。应该不会有字母和符号混在一起的关键字。

关于注释，我想单行注释可以在读入阶段就去掉，多行注释就需要修改一下自动机的结构了，例如读入"/\*"的时候进入一个特定节点，等读到"\*/"的时候再回到0。

现在已实现注释，不过是直接通过自动机的方法。

---

## 2 词法分析

## 2.1 词法分析总过程：
```cpp
Rules::initRules(is_read);
Rules::initNonTerminalStr();
if (!is_read)
{
    Rules::initFirstSet();
    // 这个阶段需要把产生式右边为空的/zero符号删掉
    Rules::deleteZero();
    Rules::initDFA();
    Rules::calActionTable();
    Rules::saveActionTable();
}
else
{
    Rules::deleteZero();
    Rules::loadActionTable();
}
```
**从`parse_rule.py`中读取文件**

使用.py只是为了方便注释。此文件所有符号必须空格，结尾加#，空行最好也要加#

**反向编码非终结符**

**初始化每个非终结符的FIRST集合**

此步需要产生式中含有空，即`/zero`，因为这样方便算。

**删掉`/zero`**

因为这样才满足分析时的实际含义。

**构建DFA**

**根据DFA构建LR(1)分析表，保存LR(1)分析表**

**实际分析中同时构建语法树，最后输出树结构**

---

## 2.2 语法问题：四朵乌云

ppt中有个看起来像是写错的问题，`<因子> -> <因子>`应该改成`<因子> -> <元素>`

此外还有一个没有在左边出现的非终结符`数组元素`，意义不明。

而真正严重的问题已经化为笼罩在物理大厦上的乌云，像这样的乌云总共有四个，但总结起来就是两片。

## 2.2.1 可赋值元素系列问题

第一个卡住的问题，在于 `6.2 借用与引用`。我们发现，按照原本给出的文法，根本无法识别`*b=2;`这样的语句！

原本的文法：
```
<因子> -> '*' <因子>  | '&' mut <因子> | '&' <因子>
```

这是因为`<赋值语句> -> <可赋值元素> '='<表达式> ';'`左边的可赋值语句并不可以推出含有引用和解引用运算符的符号串。

我们经过多次摸索改法，找到了一种较为合理的改法。

我们认为这几个名词原本意义不明。因子本义是`项`下一层而`元素`上一层的东西，是乘除同级的表达式类别的东西。如果用它来推引用和解引用，那么会出现`*1`这样匪夷所思的东西。

应该定义这些符号一定是在**可赋值元素**中。产生式改为：

```
<可赋值元素> -> '*' <可赋值元素>  | '&' mut <可赋值元素> | '&' <可赋值元素>
```

问题就解决了。

---
第二个和第三个卡住的问题在于数组和元组，按照所给文法直接照搬会出现问题。我们发现这依旧是意义不明的问题。

8.2和9.2中推出带[ ]和带.的都推到了奇怪的地方。
```
<可赋值元素> -> <元素> '[' <表达式> ']'
<可迭代结构> -> <元素>
<可赋值元素>-><因子> '.' <NUM>
```
我们定义`a[0].1`这样的都是复杂类型元素，由可赋值元素推出，语法改为即可
```
<可赋值元素> -> <复杂类型元素>
<复杂类型元素> -> <复杂类型元素> '[' <表达式> ']' | <ID> '[' <表达式> ']'
<可迭代结构> -> <可赋值元素>
<复杂类型元素> -> <复杂类型元素> '.' <NUM> | <ID> '.' <NUM>
```

为了使得可赋值元素中可以加`()`，我们还需要添加一条倒推回去的产生式：
```
<复杂类型元素> -> | "(" <可赋值元素> ")"
```
加入这个产生式后会产生歧义，即`(*(&a.3[0].1))`最外层括号可以是元素推表达式的括号，也可以是可赋值元素自己推出的括号。但是规约成哪个意义不大，可以直接按任意优先级取决冲突（见下）。

这样不能识别`*(a+1)`这样的符号串，但是rust貌似没有这种写法，只有c++有。


## 2.2.2 LOOP表达式歧义问题

在同时含有LOOP语句和LOOP表达式时，这个文法是含有歧义的！

```rust
loop{
    let mut a = 10;
    break;
}
loop{
    let mut a = 10;
    break;
};
let mut c = 10;
let mut b = loop{
    let mut a = 20;
    if(c >= 100){
        break a;
    }
    a = a + 1;
};
```
第二个`loop`和`;`，无法判断是一个`loop表达式`加`;`规约成语句，还是一个`loop语句`加`空语句`规约成语句。

解决办法：只有第二个`loop`是有歧义的，会引导DFA走向一个有冲突的项目集合。而当有先前信息（比如第三个知道`loop`前面有=），DFA可以正常判断。而事实上有歧义时，其解释为`loop表达式`还是`loop语句`是没有区别的。由于`loop语句`不用加`;`，我们在这种情况下总是将其规约成`loop语句`即可，这就相当于修改了规约的优先级。